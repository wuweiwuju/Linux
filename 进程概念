系统编程：进程概念/进程控制/基础IO/进程间通信/进程信号/多线程
进程概念：
	1.认识冯诺依曼体系结构
	2.简单认识操作系统
	3.进程概念
	4.进程状态/优先级/环境变量/进程调度
	5.程序地址空间
	
冯诺依曼体系结构：现代计算机硬件体系结构
	输入设备：键盘
	输出设备：显示器
	存储器：内存条
	运算器：
		运算器和控制器合称：中央处理器CPU
	控制器：
	
		硬件结构决定了软件行为/所有的设备都是围绕存储器工作的（重要）

操作系统：内核+应用
	功能：管理计算机软硬件资源
	定位：搞管理的软件
	目的：让计算机更加好用
	如何管理：先描述，再组织
	库函数与系统调用接口的关系：库函数封装了系统调用接口；上下级的调用关系
	进程：站在操作系统的角度，进程就是一个运行中程序描述-PCB（进程控制块）
	Linux下这个pcb实际上是一个结构体 struct task_struct{...}
	进程如何描述一个运行中的程序：
		内存指针，程序计数器，上下文数据，标识符PID，状态，优先级，记账信息，IO信息
		CPU的分时机制-每个程序在CPU上运行都有一个时间片		
		时间片：程序在CPU上给你运行的时间，运行完毕则调度切换
		进程就是PCB
		
	如何查看进程
		ps -ef / -aux
		pid_t getpid(void) 获取调用进程的ID
	
	进程状态：
		运行   就绪    阻塞
	
	Linux下的进程状态：
		运行态R/可中断休眠状态S/不可中断休眠状态D/停止状态T/死亡状态X/追踪状态t/僵死状态Z
		
		
		僵死状态：进程已经退出，但是资源没有完全释放
		僵尸进程：处于僵死状态的进程
		僵尸进程的产生：子进程先于父进程退出，为了保存退出原因，因此资源并没有完全被释放，
						因此在子进程退出时，操作系统会通知父进程，让父进程获取子进程的退出
						原因，然后释放子进程所有资源。如果父进程当前并没有关注子进程的退出
						状态，则子进程成为僵尸进程。
		僵尸进程的危害：资源泄漏
		僵尸进程的避免：进程等待
		僵尸进程的处理：退出父进程
		
		孤儿进程：父进程先于子进程退出，子进程成为孤儿进程，运行在后台，父进程成为1号进程（init进程）
				  （孤儿进程退出不会成为僵尸进程）
		
		守护进程/精灵进程：特殊的孤儿进程（在孤儿进程的基础上，脱离终端，脱离登录会话）
							（通常运行在后台，默默的工作，不希望受到终端会话的影响）
		
		进程创建：pid_t fork(void)
		通过复制调用进程创建一个子进程，子进程因为拷贝了父进程pcb里面的很多数据，因此与父进程
		内存指针以及程序计数器都相同，所以运行的代码以及运行的位置都一样
		
		返回值有三种：
			-1：创建子进程失败
			== 0：对于子进程来说，返回值是0
			>0:  对于父进程，返回值是子进程的pid
		
		进程优先级：决定进程CPU资源的优先分配权
			程序分类：CPU密集/IO密集
			进程分类：批处理/交互式
			
			renice -n 19 -p pid 设置进程的优先级
			sudo nice -n -20 ./zombie
			数字越小，优先级越高
			
		环境变量：
			概念：存放系统运行环境参数的变量
			命令：env:查看系统中环境变量
				  echo:直接打印一个指定环境变量的内容 echo $PATH
				  set:查看所有变量（包含环境变量在内）
				  export:设置一个环境变量
				  unset:删除一个环境变量
			目的：
				1.让系统运行环境参数配置更加灵活
				2.环境变量具有全局特性
			代码操作：
				char *getenv(const char* name);
				main(int argc,int *argv[],char *env[]);
				extern char **environ;
				
		程序地址空间：
			虚拟地址空间：是操作系统为进程所描述的一个假的地址空间；目的是为了让进程认为自己
						  拥有一块连续的线性的完整的地址空间；但是实际上一个进程使用的内存并
						  非连续存储，而是通过页表映射了虚拟地址与物理地址之间的关系；让进程
						  通过页表获取物理地址，进而实现数据的离散式存储
			这个虚拟地址空间实际上是一个mm_struct所描述的空间---内存描述符
			作用：1.提高内存的利用率：物理内存的离散存储
				  2.保证了进程独立性：每个进程只能访问自己的虚拟地址映射的物理内存
				  3.页表可以进行内存访问控制：页表可以对每个虚拟地址进行权限标记
			创建一个子进程的流程：写时拷贝技术
				1.创建pcb
				2.拷贝父进程pcb中的数据（拥有相同的虚拟地址空间，相同的页表...）
				3.父子进程一开始映射同一块物理内存
				4.等到物理内存修改的时候才为子进程重新开辟内存，拷贝数据过来（要求进程的独立性）
			
			代码共享和数据独有：因为代码段是只读的，因此会一直映射同一块物理内存
		
			内存管理：
				分段式：对程序中的地址管理比较友好，但是内存利用率不高---段号+段内偏移
				分页式：提高内存的利用率
					一个虚拟地址的构成：页号+页内偏移			
					页面：4096 物理内存：4G  页表：（4*1024*1024*1024）/4096
				段页式：目前采用的方案
				
				物理地址的计算方法：（虚拟地址/页面大小）= 页号    通过页表得到块号
									 块号*块大小 + 页内偏移（虚拟地址%页面大小）
				
			进程调度：操作系统通过调度pcb来实现调度程序在CPU上执行
				  
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		